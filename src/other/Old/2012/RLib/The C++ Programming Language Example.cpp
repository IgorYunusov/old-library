/*************************************************
 *												 *
 *				RollRat Software 				 *
 *												 *
 *	Copyright (c) rollrat. All rights reserved.  *
 *_______________________________________________*/

/*-------------------------------------------------

					Head Line

	This file made that it's because provides
	newcomer more detail information, so that
	i write this file with soft eng-lang. For 
	more information you can get through this 
	file. Thank for you, i can get more than
	previous.

-------------------------------------------------*/

// 이 파일은 C++에 대한 좀더 상세한 내용을 제공합니다.

/********************
*1. 클래스와 기본형
*	이 구역에서는 클래스와 템플릿에 관하여 배웁니다.
*	- 가상함수에 대한 내용을 뒤로 옮겨서 설명합니다.
*	- 상속에 대한 내용을 뒤로 옮겨서 설명합니다.
*/

/*================================================

				1. 클래스와 기본형

			- 기본형 클래스와 생성과 소멸

================================================*/

class _Example_Class1{};  // 클래스의 표준형 선언입니다.

class _Example_Class2	// 클래스의 일반형 표시입니다.\
		표준형으로는 생성자와 소멸자가 있습니다.
{
public:	// 공동재산 구분입니다. 여기 밑으로 선언되는 모든것은\
			클래스 외부에서도 조작가능합니다.
	_Example_Class2(); // 생성자로써 중복이 가능하며 이때 인수의 값이 달라야\
			합니다.
	~_Example_Class2();	// 일반적인 소멸자 선언으로써\
			0개의 인수를 받아 들이며, 클래스당 1개만 선언 가능합니다.
private:	// 사유재산 구분입니다. 여기 밑으로 선언되는 모든것은\
				클래스 내부에서만 사용가능합니다.
};
_Example_Class2::_Example_Class2() // 클래스 외부에 생성자 선언입니다.\
			템플릿 클래스가 아닌경우 바깥에 쓰는 것을 원칙으로 합니다.
{
}
_Example_Class2::~_Example_Class2() // 클래스 외부에 소멸자 선언입니다.
{
}

/*================================================

				1. 클래스와 기본형

			- 템플릿 클래스와 생성과 소멸

================================================*/

 // 템플릿 선언입니다. <와 >사이에 다음과 같이 들어 갈 수 있습니다.
template<>			// 빈 템플릿. 일반적인 컴파일러에 경우 무시되거나\
					 오류를 발생시킵니다.
template<class _P>	// class형 템플릿 입니다. typename과 차이는 없습니다.
template<typename _P> // 위와 동일 합니다.

template<class __T> 
class _Example_Class3{}; // 템플릿 클래스의 표준형 선언입니다.

template<class _Ty0>
class _Example_Class4
{
public:
	_Example_Class4()	// 템플릿 클래스의 경우 관습적으로 클래스 내부에\
				직접 선언을 원칙으로 합니다.
	: Private_Int_1(0)	// 인수의 초기값을 대입시킵니다. 이때 내부의 인수의\
				상세한 조작은 금지되며, 간단한 대입만 가능합니다.
	{
	Private_Int = new _Ty0[5];	// 생성자의 역할로 메모리에 배열 5만큼 할당\
						시킵니다.
	Private_Int[5] = 10; // 값을 대입합니다.
	}
	explicit _Example_Class4(_Ty0& _First) // explicit은 함수가\
				'='연산자에 의하여 강제 호출됨을 컴파일러로부터 방지시킵니다.
	: Private_Int_1(_First)
	{
	Private_Int = new _Ty0[5];	// 생성자의 역할로 메모리에 배열 5만큼 할당\
						시킵니다.
	Private_Int[5] = 10; // 값을 대입합니다.
	}
	~_Example_Class4()
	{
	delete[] Private_Int; // 소멸자의 역할로 클래스가 외부와 분리되면 소멸자가 동작\
				함과 동시에 이 소멸자 함수가 호출됨으로써 할당받은 배열을 제거할 기회를\
				부여합니다.
	}
private:
	_Ty0 *Private_Int;	// 클래스 내부의 선언
	_Ty0 Private_Int_1;
};

/*================================================

				1. 클래스와 기본형

				- 변덕스러운 키워드

================================================*/

class _Example_Class5
{
public:
	int& const_call() const // const형식은 '읽기전용'형식과 비슷합니다.
	{
	integer_1 = 0; // mutable처리 되지 않은 선언은 const에서 값을 대입하면\
			오류를 발생시킵니다.
	integer = 1; // mutable처리 시켰으므로 const내에서 return시키지 않는\
			방식으로 처리당할수 있습니다.
	return integer_1; // 바인딩 참조에서 한정자가 삭제되어 integer_1을 참조\
			형식으로 내보낼수 없습니다.
	return integer = 1; // 값을 내보내어 쓸수 있습니다.
	}
private:
	mutable int integer;
	int integer_1;
};

///////////////////////////////////////////////////////

/********************
*2. 오버로딩과 오버로드
*	이 구역에서는 연산자의 오버로딩에 관하여 자세히 배웁니다.
*	함수에 관한 오버로드를 오버로딩이라고 하고,
*	그 이외에 연산자 오버로드를 그냥 오버로드라 지칭합니다.
*/

/*================================================

			2. 오버로딩과 오버로드

			- 함수 오버로드(오버로딩)

		* 템플릿 함수의 오버로드는 인수의 개수가 같은
		경우 일반적으로 불가능 합니다. 이 점을 명시
		하여 주시기 바랍니다.

================================================*/

int _Example_Overloading1(int f)
	{
	return f < 0 ? 1 : 2;
	}
int _Example_Overloading1(char f)
	{
	return f < 0 ? 1 : 2;
	}

// 위 두함수는 오버로드 되었습니다.
// 두 함수의 이름은 같지만 받는 인수가 다르므로
// 오버로드 가능한 함수 입니다.

template<class _Ty0>
	void _Ff_Overloading2(_Ty0 *ex)
	{
	ex = 0;
	}
template<class _Ty0>
	void _Ff_Overloading2(_Ty0 ex)
	{
	ex = 0;
	}

// 위 두함수는 C++의 규칙상으로 오버로드
// 된 함수가 틀림없습니다.
// 하지만 템플릿 오버로딩의 경우 함수의 표기만
// 다르다고 다른 인수로 받아드리지 못합니다.
// 예를들어 _Ff_Overloading2((int f= 0, f));을 호출 해보십시오.

/*================================================

			2. 오버로딩과 오버로드

			- 연산자 오버로드

		* 템플릿 함수의 오버로드는 인수의 개수가 같은
		경우 일반적으로 불가능 합니다. 이 점을 명시
		하여 주시기 바랍니다.

================================================*/

